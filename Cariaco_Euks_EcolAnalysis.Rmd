---
title: "Cariaco_Euks_PostAnalysis"
author: "Liz Suter"
date: "5/26/2020"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# Load libraries

```{r}
library(tidyverse)
library(phyloseq)
library(phangorn)
library(readr)
#library(seqinr)
library(ape)
library(vegan)
library(RColorBrewer)
library(microbiome)
library(compositions)
library(SpiecEasi)
library(otuSummary)
library(psych)
library(Matrix)
library(igraph)


# Helper functions from J. Cram https://biovcnet.github.io/_pages/NetworkScience_SparCC.nb
pass <- function(x){x} 
# Get lower triangle of the correlation matrix
  get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
# Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }

reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

reorder_cor_and_p <- function(cormat, pmat){
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
  pmat <- pmat[hc$order, hc$order]
  list(r = cormat, p = pmat)
}

#Custom colorblind pallette, see: https://stackoverflow.com/questions/57153428/r-plot-color-combinations-that-are-colorblind-accessible
customvermillion<-rgb(213/255,94/255,0/255)
custombluegreen<-rgb(0/255,158/255,115/255)
customblue<-rgb(0/255,114/255,178/255)
customskyblue<-rgb(86/255,180/255,233/255)
customreddishpurple<-rgb(204/255,121/255,167/255) 
```

- Note for SpiecEasi, installation instructions are [here](https://github.com/zdk123/SpiecEasi). On Mac, there are issues with a dependency which I also had to update using these [instructions](https://thecoatlessprofessor.com/programming/cpp/r-compiler-tools-for-rcpp-on-macos/)


# Prepare the data

## Import 

Metadata:
```{r}
metadata <- read_csv("Metadata.csv")
```

Import SRA table and match SRA IDs with sample IDs in metadata file
```{r}
SRARunTable <- read_csv("sra_data/SraRunTable.txt")
metadata <- left_join(metadata, SRARunTable, by = 'Sample Name')
```



DADA2 results:
```{r}
# Import Count table. Skip first row of tsv file, which is just some text
count_table <- read_tsv(file="dada2_export/ASVs_counts.tsv")
# And specify that the first column of data are rownames
count_table <- column_to_rownames(count_table, var = colnames(count_table)[1])

# Import taxonomy of ASVs
taxonomy <- read_tsv(file="dada2_export/ASVs_taxonomy.tsv")
# And specify that the first column of data are rownames
taxonomy <- column_to_rownames(taxonomy, var = colnames(taxonomy)[1])
```


## QC and Filtering

### Rarefaction curves

```{r}
# Use rarecurve, from the Vegan package. Rarcurve expects the dataset as a dataframe so we need to use as.data.frame again:
count_table_df <- as.data.frame(count_table)

# Plot the rarefaction curves, color-coding by the colors listed in sample_info_tab, which indicate sample type, and transforming using t() again
# Running this 5-10 samples at a time because otherwise it takes a long time to render
rarecurve(t(count_table_df), step=100, cex=0.5, ylab="ASVs", label=T)
```


### Remove singletons

```{r}
count_table_no_singletons <- filter(count_table,rowSums(count_table)>1)
# retains all ASVs (out of 14176)
```

and change sample names from NCBI ID to our internal sample IDs
```{r}
# Modify taxa names in count_table_no_singletons, which are the NCBI SRA numbers. Want to use our internal sample key
key <- SRARunTable %>% select(Run, 'Sample Name')

x <- (t(count_table_no_singletons))
x <- as.data.frame(cbind(x, Run = rownames(x)))

y <- t(left_join(x, key, by = "Run"))
colnames(y) <- y['Sample Name',]
y <- y[ !(rownames(y) %in% c('Sample Name', 'Run')), ]

count_table_2 <- type_convert(as.data.frame(y))
```

### Make Phylo Tree  
This process takes a LONG time so run once and save .RData object
In the Dada2 tools, there are no options to build a tree (unlike in Qiime2) but we can build it here using DECIPHER and phangorn

(Based on [https://f1000research.com/articles/5-1492/v2](https://f1000research.com/articles/5-1492/v2))


Make an alignment using tools from Decipher (Note- alignment step takes several hours. Commented out for now. Only need to run once) 
```{r}
## import fasta
# fas <- "dada2_export/ASVs.fa"
# seqs <- readDNAStringSet(fas)
# seqs
# 
# # perform the alignment
# aligned <- AlignSeqs(seqs) # automatically detects and uses all cores
# 
# # view the alignment in a browser (optional)
# BrowseSeqs(aligned, highlight=0)
# 
# # write out aligned sequence file
# writeXStringSet(aligned, file="ASVs.aligned.fasta")
```


Use phangorn package to build tree. Here we are building a maximum likelihood neighbor-joining tree. (Also takes a while to run. Comment out for now.)

```{r}
# phang.align <- phyDat(as(aligned, "matrix"), type="DNA") # convert to phyDat format
# dm <- dist.ml(phang.align) # calculate pairwise distance matrix
# treeNJ <- NJ(dm) # perform neighbor-joining tree method
# fit = pml(treeNJ, data=phang.align) # compute intermal max likelihood
```

#### Save and re-load dataset
Since the step above takes a long time, save all variables up to this point in environment as RData object
```{r}
# save.image("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_tree.RData")
```

Re-load
```{r}
load("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_tree.RData")
```


### Make phyloseq objects

Here we will do ordinations using the phyloseq package, which first requires making phyloseq objects out of each of our input data tables (in the last tutorial, I imported the tree using phyloseq so it is already a phyloseq object)

```{r}
ASV	=	otu_table(count_table_2, taxa_are_rows =  TRUE)
TAX	=	tax_table(as.matrix(taxonomy))
META	=	sample_data(data.frame(metadata, row.names = metadata$`Sample Name`))
TREE = phy_tree(fit$tree)
```



First check that the inputs are in compatible formats by checking for ASV names with the phyloseq function, taxa_names
```{r}
head(taxa_names(TAX))
head(taxa_names(ASV))
head(taxa_names(TREE))
```


And check sample names were also detected
```{r}
head(sample_names(ASV))
head(sample_names(META))
```

And make the phyloseq object
```{r}
ps <- phyloseq(ASV,	TAX,	META , TREE)
```



Check some features of the phyloseq object
```{r}
rank_names(ps)
table(tax_table(ps)[, "Supergroup"], exclude = NULL)
unique(tax_table(ps)[, "Supergroup"])
```


Filter out those ambigious Supergroup annotations- losing 471 ASVs
```{r}
ps <- subset_taxa(ps, !is.na(Supergroup) & !Supergroup %in% c("", "NA"))
table(tax_table(ps)[, "Supergroup"], exclude = NULL)
```

Check out the Division names
```{r}
table(tax_table(ps)[, "Division"], exclude = NULL)
```


Filter out any with "NA" as Division 
```{r}
ps <- subset_taxa(ps, !is.na(Division) & !Division %in% c(""))
table(tax_table(ps)[, "Division"], exclude = NULL)
```
After the above, 13,427 ASVs remain from the original 14,177


Eliminate the libraries that didn't have many sequences, AE3a198A, AE3b314A, AE2a200A, AE2b900AN, AE2a200B, AE2a267B, AE2a900BN
```{r}
taxa_to_keep <- !sample_names(ps) %in% c("AE3a198A","AE3b314A","AE2a200A","AE2b900AN","AE2a200B","AE2a267B","AE2a900BN")
ps <- prune_samples(taxa_to_keep, ps)
```
41 samples remain and stil 13,427 ASVs



Check rarefaction curve again to make sure those low-sqeuencing-effort samples have been removed
```{r}
rarecurve(t(otu_table(ps)), step=100, cex=0.5, ylab="ASVs", label=T)
```



### Re-root tree 
Have to do this because you may have removed the root of your tree when pruning). 
(I found this handy function from [here](https://john-quensen.com/r/unifrac-and-tree-roots/) which picks the longest branch to root from). 

```{r}
# first define function from link above to find furthest outgroup
pick_new_outgroup <- function(tree.unrooted){
require("magrittr")
require("data.table")
require("ape") # ape::Ntip
# tablify parts of tree that we need.
treeDT <- 
     cbind(
         data.table(tree.unrooted$edge),
         data.table(length = tree.unrooted$edge.length)
     )[1:Ntip(tree.unrooted)] %>% 
 cbind(data.table(id = tree.unrooted$tip.label))
 # Take the longest terminal branch as outgroup
 new.outgroup <- treeDT[which.max(length)]$id
 return(new.outgroup) }

# then run on my phyloseq tree
my.tree <- phy_tree(ps)
out.group <- pick_new_outgroup(my.tree)
out.group

# Then use this outgroup to root the tree
new.tree1 <- ape::root(my.tree, outgroup=out.group, resolve.root=TRUE)


phy_tree(ps) <- new.tree1

# Check if tree is binary (dichotomous not multichotomous)
is.binary.tree(phy_tree(ps))

# If false, would have to run
# new.tree2 <- ape::multi2di(new.tree1)
# phy_tree(ps) <- new.tree2
# phy_tree(ps)


```

### Check phyla using bar plots

Check overall how the phyla are distributed among samples. Phyloseq makes this easy

```{r}
# First aglomerate the ASVs at the phylum level using the phyloseq function, tax_glom
DivisionGlommed = tax_glom(ps, "Division")

# There are many phyla here, so have to make a custom color palette by interpolating from an existing one in RColorBrewer
colourCount = length(table(tax_table(ps)[, "Division"], exclude = NULL))
getPalette = colorRampPalette(brewer.pal(11, "Spectral"))
DivisionPalette = getPalette(colourCount)

# and plot
plot_bar(DivisionGlommed, x = "Sample", fill = "Division") + 
  scale_fill_manual(values = DivisionPalette)
```



Plot compositional (relative abundances) instead of absolute abundance using microbiome::transform

```{r}
ps_ra <- microbiome::transform(ps, transform = "compositional")
(otu_table(ps_ra))[1:5,1:5]
```


```{r}
# Then aglomerate the ASVs at the phylum level using the phyloseq function, tax_glom
DivisionGlommed_RA = tax_glom(ps_ra, "Division")
# and plot
Division_barplot <- plot_bar(DivisionGlommed_RA, x = "Sample", fill = "Division") + 
  scale_fill_manual(values = DivisionPalette) +
  theme(legend.text = element_text(size = 10))
  

Division_barplot

# export
ggsave("Figures/Division_barplot.eps",Division_barplot, width = 15, height = 5, units = c("in"))
```

Lots of dinoflagellates and radiolaria. Makes sense. But the above is the distribution from all samples. Next make plots that indicate distributions across environmental gradients. Calculate averages and use bubble plots





### Calculate averages from replicates
Get average relative abundances from sample replicates
```{r}

otu_table_mean_ra <- 
  mutate(data.frame(otu_table(ps_ra)), "103A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a103A","AE3b103A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "198A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3b198A")), na.rm = TRUE))  %>% # Sample AE3a198A was removed
  mutate(data.frame(otu_table(ps_ra)), "234A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a234A","AE3b234A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "295A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a295A","AE3b295A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "314A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a314A")), na.rm = TRUE)) %>%  # Sample AE3b314A was removed
  mutate(data.frame(otu_table(ps_ra)), "900AM" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a900AM","AE1b900AM")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "103B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a103B","AE3b103B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "198B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a198B","AE3b198B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "234B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a234B","AE3b234B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "295B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a295B","AE3b295B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "314B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a314B","AE3b314B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "900BM" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE3a900BM","AE1b900BM")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "143A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a143A","AE2b143A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "200A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2b200A")), na.rm = TRUE)) %>% # AE2a200A was removed
  mutate(data.frame(otu_table(ps_ra)), "237A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a237A","AE2b237A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "247A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a247A","AE2b247A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "267A" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a267A","AE2b267A")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "900AN" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a900AN")), na.rm = TRUE)) %>% # AE2b900AN was removed
  mutate(data.frame(otu_table(ps_ra)), "143B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a143B","AE2b143B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "200B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2b200B")), na.rm = TRUE)) %>% # AE2a200B was removed
  mutate(data.frame(otu_table(ps_ra)), "237B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a237B","AE2b237B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "247B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2a247B","AE2b247B")), na.rm = TRUE)) %>%
  mutate(data.frame(otu_table(ps_ra)), "267B" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2b267B")), na.rm = TRUE)) %>% # AE2a267B was removed
  mutate(data.frame(otu_table(ps_ra)), "900BN" = rowMeans(select(data.frame(otu_table(ps_ra)), c("AE2b900BN")), na.rm = TRUE)) # AE2a900BN was removed

otu_table_mean_ra <- otu_table_mean_ra[,unique(metadata$Replicate)]

otu_table_mean_ra
```

Make into new phyloseq object
```{r}
metadata2 <- unique(select(metadata,!c('Sample Name',Type,colnames(SRARunTable))))
META2 <- sample_data(data.frame(metadata2, row.names = metadata2$Replicate))

ps_ra_mean <- phyloseq(otu_table(otu_table_mean_ra, taxa_are_rows = TRUE), TAX, TREE, META2)
```


```{r}
# First aglomerate the ASVs at the phylum level using the phyloseq function, tax_glom
ps_ra_mean_division <- tax_glom(ps_ra_mean, "Division")


# and check by bar plotting
plot_bar(ps_ra_mean_division, x = "Sample", fill = "Division") + 
  scale_fill_manual(values = DivisionPalette)
```

# Abundance Plots

## Prepare data

Extract mean relative abundance, glommed by division, from the phyloseq object and pair it to taxonomic data
```{r}
division_df <- data.frame(otu_table(ps_ra_mean_division))
colnames(division_df) <- colnames(otu_table(ps_ra_mean_division))
division_df$ASV <- rownames(division_df)

otu_table_mean_ra <- left_join(division_df, as_tibble(taxonomy, rownames = "ASV"), by = "ASV")
otu_table_mean_ra
```


Pivot longer
```{r}
otu_table_mean_ra <- pivot_longer(otu_table_mean_ra, cols = unique(metadata$Replicate), names_to = "Replicate", values_to = "Mean_RA")
otu_table_mean_ra
```


Join metadata 
```{r}
otu_table_mean_ra <- left_join(otu_table_mean_ra, unique(select(metadata, c("Replicate", "Depth", "SizeFraction", "Season", "OxCond", "Fluorescence", "BeamAtt", "O2", "Temp", "Salinity", "H2S", "ParticulateS", "TZVS", "CH4", "NO3", "NO2", "NH4", "PO4", "Chemoautotrophy", "BNP", "MicroAbun(x10^8 L^-1)", "FlagAbun(x10^5 L-1)", "VLP(x10^8 L-1)"))), by = "Replicate")

# Replace zeroes in RA with NA (better for plotting)
otu_table_mean_ra$Mean_RA[otu_table_mean_ra$Mean_RA == 0] <- NA

otu_table_mean_ra
```


## Bubble Plot of Divisions

```{r}
# reorder some factors to make them plot in the order I want
otu_table_mean_ra$OxCond <- factor(otu_table_mean_ra$OxCond, levels = c("Oxycline", "ShallowAnoxic", "Euxinic"))
otu_table_mean_ra$SizeFraction <- factor(otu_table_mean_ra$SizeFraction, levels = c("PA", "FL"))

euk_divisions_bubbleplot_color <- ggplot(otu_table_mean_ra,aes (x = as.character(Depth), y = reorder(Division, Mean_RA, function(x){sum(x,na.rm = TRUE)}), color = OxCond)) + 
  geom_point(aes(size =Mean_RA))+
  facet_wrap(Season~SizeFraction, scales = "free_x", drop= TRUE, ncol = 4) +
  scale_size(range = c(1,15)) +
  scale_size_area(breaks = c(0,.25,.5,.75,1), max_size = 6) +
  xlab("Depth") +
  ylab("") +
  labs(size="Relative Abundance", color = "Redox Condition") +
   scale_color_manual(values = c("blue", "red", "brown4")) +
  theme_bw() +
  theme(axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10),
        axis.title.x= element_text(size=12),
        axis.title.y= element_text(size=12))

euk_divisions_bubbleplot_color
```

Save figure
```{r}
ggsave(filename = "Figures/euk_divisions_bubbleplot_color.eps", plot = euk_divisions_bubbleplot_color, units = c("in"), width = 10, height = 6, dpi = 300)
```


#### Save and re-load dataset
```{r}
# save.image("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_bubbleplots.RData")
```

Re-load
```{r}
load("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_bubbleplots.RData")
```


# Correlation Analyses

## Prepare the data

### Import prokaryote dataset from Suter et al. 2018

Import
```{r}
arch_counts <- read_csv("Suter_2018_count_tables/Cariaco_AA_updated_raw.csv");
bac_counts <- read_csv("Suter_2018_count_tables/Cariaco_AB_updated_raw.csv");
```

Get sample names
```{r}
bac_samples <- colnames(bac_counts)[2:49]
arch_samples <- colnames(arch_counts)[2:47]

bac_samples
arch_samples
```

Make separate taxonomy and count variables
```{r}
arch_OTU <- arch_counts[,c("#OTU ID",arch_samples)]
arch_taxonomy <-  arch_counts %>%
  select(-arch_samples)  %>%
  select(-Sum)

arch_OTU
arch_taxonomy

bac_OTU <- bac_counts[,c("#OTU ID",bac_samples)]
bac_taxonomy <-  bac_counts %>%
  select(-bac_samples)  %>%
  select(-Sum) %>%
  select(-"Interesting close relatives")

bac_OTU
bac_taxonomy
```


### Make into phyloseq objects
```{r}
bac_OTU <- type_convert(as.data.frame(bac_OTU))
rownames(bac_OTU) <- bac_OTU$`#OTU ID`
bac_OTU <- bac_OTU[,!names(bac_OTU) %in% (c("#OTU ID"))]

bac_OTU	=	otu_table(bac_OTU, taxa_are_rows =  TRUE)
#
arch_OTU <- type_convert(as.data.frame(arch_OTU))
rownames(arch_OTU) <- arch_OTU$`#OTU ID`
arch_OTU <- arch_OTU[,!names(arch_OTU) %in% (c("#OTU ID"))]

arch_OTU	=	otu_table(arch_OTU, taxa_are_rows =  TRUE)
#
bac_TAX <- type_convert(as.data.frame(bac_taxonomy))
rownames(bac_TAX) <- bac_TAX$`#OTU ID`
bac_TAX <- bac_TAX[,!names(bac_TAX) %in% (c("#OTU ID"))]

bac_TAX	=	tax_table(as.matrix(bac_TAX))
#
arch_TAX <- type_convert(as.data.frame(arch_taxonomy))
rownames(arch_TAX) <- arch_TAX$`#OTU ID`
arch_TAX <- arch_TAX[,!names(arch_TAX) %in% (c("#OTU ID"))]

arch_TAX	=	tax_table(as.matrix(arch_TAX))
#
META	=	sample_data(data.frame(metadata, row.names = metadata$`Sample Name`))
#

ps_bac <- phyloseq(bac_OTU,	bac_TAX,	META)
ps_arch <- phyloseq(arch_OTU,	arch_TAX,	META)
```

Filter out the samples with low sequencing effort. These were previously identified for itags paper

```{r}
taxa_to_keep_b <- !sample_names(ps_bac) %in% c("AB3a900A","AB2a200A","AB2b267A")
ps_bac <- prune_samples(taxa_to_keep_b, ps_bac)

taxa_to_keep_a <- !sample_names(ps_arch) %in% c("AA2b900AN","AA2a247B","AA2a900BN","AA2b900BN")
ps_arch <- prune_samples(taxa_to_keep_a, ps_arch)
```


### Filtering

First calculate relative abdunance of bac and arch OTU tables
```{r}
ps_bac_ra <- microbiome::transform(ps_bac, transform = "compositional")
(otu_table(ps_bac_ra))[1:5,1:5]

ps_arch_ra <- microbiome::transform(ps_arch, transform = "compositional")
(otu_table(ps_arch_ra))[1:5,1:5]
```


### Filter low abundance species from full dataset

Remove rows of glommed taxa from the full dataframe if their sum across all samples doesn't exceed 5% (RA > 0.05) 
```{r}
# Bacteria
x <- taxa_sums(ps_bac_ra)
# keepTaxa <-  base::which(x  > .05)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_bac_ra_pruned <-  prune_taxa(keepTaxa, ps_bac_ra)
ps_bac_pruned <-  prune_taxa(keepTaxa, ps_bac)
ps_bac_ra_pruned
ps_bac_pruned

# Archaea
x <- taxa_sums(ps_arch_ra)
# keepTaxa <-  base::which(x  > .05)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_arch_ra_pruned <-  prune_taxa(keepTaxa, ps_arch_ra)
ps_arch_pruned <-  prune_taxa(keepTaxa, ps_arch)
ps_arch_ra_pruned
ps_arch_pruned

# Eukaryotes
x <- taxa_sums(ps_ra)
# keepTaxa <-  base::which(x  > .05)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_euk_ra_pruned <-  prune_taxa(keepTaxa, ps_ra)
ps_euk_pruned <-  prune_taxa(keepTaxa, ps)
ps_euk_ra_pruned
ps_euk_pruned
```
Trimmed to 124 bacteria OTUs, 52 archaea OTUs, and 123 eukaryotic ASVs (299 total). Proceed with this dataset of the most abundant OTUs for correlations and network analyses...

To do the multi-domain analysis, the sample names from each phyloseq object must match. These currently have "B" for bacteria, A, E etc. Remove this letter from sample names so that "AE2a247B", "AA2a247B", "AB2a247B" all become just "Type" from the metadata sheet [IntNov1FL in this case- for Interface, November, rep 1, free-living]. 

Import my SampleKey
```{r}
samplekey <- read_csv("SampleKey.csv")
```


Change the sample names in the otu tables to sample "Type"
```{r}
# Archaea
# remove missing archaea samples from samplekey_A
samplekey_A <- filter(samplekey, SampleID_arch  %in% colnames(otu_table(ps_arch_ra_pruned)))
# sort SampleKey by order of column names from ps_arch_ra_pruned
samplekey_A <- samplekey_A %>% arrange(factor(SampleID_arch, levels = colnames(otu_table(ps_arch_ra_pruned))))
# replace col names of otu table from ps_arch_ra_pruned
sample_names(ps_arch_ra_pruned) <- samplekey_A$Type
# and ps_arch_pruned
sample_names(ps_arch_pruned) <- samplekey_A$Type


# Bacteria
samplekey_B <- filter(samplekey, SampleID_bac  %in% colnames(otu_table(ps_bac_ra_pruned)))
samplekey_B <- samplekey_B %>% arrange(factor(SampleID_bac, levels = colnames(otu_table(ps_bac_ra_pruned))))
sample_names(ps_bac_ra_pruned) <- samplekey_B$Type
sample_names(ps_bac_pruned) <- samplekey_B$Type


# Eukaryotes
samplekey_E <- filter(samplekey, SampleID_euk  %in% colnames(otu_table(ps_euk_ra_pruned)))
samplekey_E <- samplekey_E %>% arrange(factor(SampleID_euk, levels = colnames(otu_table(ps_euk_ra_pruned))))
sample_names(ps_euk_ra_pruned) <- samplekey_E$Type
sample_names(ps_euk_pruned) <- samplekey_E$Type


```


Move all pruned otu tables into one table by matching the sample Type- will use this for SparCC
```{r}
alldomains_df <- bind_rows(data.frame(otu_table(ps_bac_pruned)), data.frame(otu_table(ps_arch_pruned)), data.frame(otu_table(ps_euk_pruned)))
alldomains_df
```

Change row names from "denovoXXX" to meaningful names
```{r}
alldomains_df_full <- cbind(ID = rownames(alldomains_df), alldomains_df)

# start with only first rows, which are bacteria. make one column of meaningful labels
temp1 <- left_join(alldomains_df_full[1:dim(otu_table(ps_bac_pruned))[1],], bac_taxonomy, by = c("ID" = "#OTU ID")) 
temp1$New_ID <- paste(temp1$ID, temp1$"taxonomy-2", temp1$"taxonomy-3", temp1$"taxonomy-4")
temp1 <- select(temp1,-colnames(bac_taxonomy[,2:11]))

# next rows are the archaea 
temp2 <- left_join(alldomains_df_full[sum(dim(otu_table(ps_bac_pruned))[1],1):sum(dim(otu_table(ps_bac_pruned))[1],dim(otu_table(ps_arch_pruned))[1]),], arch_taxonomy, by = c("ID" = "#OTU ID")) 
temp2$New_ID <- paste(temp2$ID, temp2$"taxonomy-2", temp2$"taxonomy-3")
temp2 <- select(temp2,-colnames(arch_taxonomy[,2:9]))


# last rows are eukarya
euk_taxonomy <- cbind("#ASV ID" = rownames(taxonomy), taxonomy)
temp3 <- left_join(alldomains_df_full[sum(dim(otu_table(ps_arch_pruned))[1], dim(otu_table(ps_bac_pruned))[1],1):sum(dim(otu_table(ps_arch_pruned))[1], dim(otu_table(ps_bac_pruned))[1],dim(otu_table(ps_euk_pruned))[1]),], euk_taxonomy, by = c("ID" = "#ASV ID")) 
temp3$New_ID <- paste(temp3$ID, temp3$"Supergroup", temp3$"Division", temp3$"Class", temp3$"Order")
temp3 <- select(temp3,-colnames(euk_taxonomy[,2:9]))

# combine back all 3 domains, with new names as row names in a dataframe
alldomains_df_full <- rbind(temp1, temp2, temp3)
alldomains_df_full <- data.frame(alldomains_df_full)
rownames(alldomains_df_full) <- alldomains_df_full$New_ID
alldomains_df_full <- select(alldomains_df_full, -c("ID","New_ID"))

```



Remove columns with NAs. These are samples for which the library for at least one domain didn't work (can't do correlations with missing values in columns)
```{r}
alldomains_df_full <- alldomains_df_full %>%
    select_if(~ !any(is.na(.)))
t(alldomains_df_full)[1:5,1:5]

alldomains_df <- alldomains_df %>%
    select_if(~ !any(is.na(.)))
t(alldomains_df)[1:5,1:5]
```
36 samples remain for correlation


### Filter low abundance species- oxycline depths only
Simlarly, make pruned datasets of the most abundant OTUs/ASVs in the oxycline, anoxic, and euxinic samples as separate datasets

Pull out samples and taxa from each redox regime
```{r}
# Pull out oxycline bacteria sample IDs
oxyclinetypes_bac <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_bac)) %>%
  filter(OxCond == "Oxycline") %>% 
  select("Sample Name")
oxyclinetypes_bac <- unlist(c(unique(oxyclinetypes_bac)), use.names = FALSE)

# Pull out all bacteria from oxycline
ps_bac_oxycline <-  prune_samples(oxyclinetypes_bac, ps_bac)
ps_bac_ra_oxycline <-  prune_samples(oxyclinetypes_bac, ps_bac_ra)


# Pull out oxycline archaea sample IDs
oxyclinetypes_arch <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_arch)) %>%
  filter(OxCond == "Oxycline") %>% 
  select("Sample Name")
oxyclinetypes_arch <- unlist(c(unique(oxyclinetypes_arch)), use.names = FALSE)

# Pull out all archaea from oxycline
ps_arch_oxycline <-  prune_samples(oxyclinetypes_arch, ps_arch)
ps_arch_ra_oxycline <-  prune_samples(oxyclinetypes_arch, ps_arch_ra)


# Pull out oxycline eukaryotic sample IDs
oxyclinetypes_euk <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps)) %>%
  filter(OxCond == "Oxycline") %>% 
  select("Sample Name")
oxyclinetypes_euk <- unlist(c(unique(oxyclinetypes_euk)), use.names = FALSE)

# Pull out all eukaryotes from oxycline
ps_euk_oxycline <-  prune_samples(oxyclinetypes_euk, ps)
ps_euk_ra_oxycline <-  prune_samples(oxyclinetypes_euk, ps_ra)

```

Filter out low abundance taxa from the oxycline samples. Use 5% as cutoff 
```{r}
# Bacteria
x <- taxa_sums(ps_bac_ra_oxycline)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_bac_ra_oxycline_pruned <-  prune_taxa(keepTaxa, ps_bac_ra_oxycline)
ps_bac_oxycline_pruned <-  prune_taxa(keepTaxa, ps_bac_oxycline)
ps_bac_ra_oxycline_pruned
ps_bac_oxycline_pruned

# Archaea
x <- taxa_sums(ps_arch_ra_oxycline)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_arch_ra_oxycline_pruned <-  prune_taxa(keepTaxa, ps_arch_ra_oxycline)
ps_arch_oxycline_pruned <-  prune_taxa(keepTaxa, ps_arch_oxycline)
ps_arch_ra_oxycline_pruned
ps_arch_oxycline_pruned

# Eukaryotes
x <- taxa_sums(ps_euk_ra_oxycline)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_euk_ra_oxycline_pruned <-  prune_taxa(keepTaxa, ps_euk_ra_oxycline)
ps_euk_oxycline_pruned <-  prune_taxa(keepTaxa, ps_euk_oxycline)
ps_euk_ra_oxycline_pruned
ps_euk_oxycline_pruned

```
79 bacteria, 36 archaea, 76 eukaryota remain


Change the sample names in the otu tables to "Type"
```{r}
# Archaea
# remove missing archaea samples from samplekey_A
samplekey_A <- filter(samplekey, SampleID_arch  %in% colnames(otu_table(ps_arch_ra_oxycline_pruned)))
# sort SampleKey by order of column names from ps_arch_ra_oxycline_pruned
samplekey_A <- samplekey_A %>% arrange(factor(SampleID_arch, levels = colnames(otu_table(ps_arch_ra_oxycline_pruned))))
# replace col names of otu table from ps_arch_ra_oxycline_pruned
sample_names(ps_arch_ra_oxycline_pruned) <- samplekey_A$Type
# and ps_arch_pruned
sample_names(ps_arch_oxycline_pruned) <- samplekey_A$Type


# Bacteria
samplekey_B <- filter(samplekey, SampleID_bac  %in% colnames(otu_table(ps_bac_ra_oxycline_pruned)))
samplekey_B <- samplekey_B %>% arrange(factor(SampleID_bac, levels = colnames(otu_table(ps_bac_ra_oxycline_pruned))))
sample_names(ps_bac_ra_oxycline_pruned) <- samplekey_B$Type
sample_names(ps_bac_oxycline_pruned) <- samplekey_B$Type


# Eukaryotes
samplekey_E <- filter(samplekey, SampleID_euk  %in% colnames(otu_table(ps_euk_ra_oxycline_pruned)))
samplekey_E <- samplekey_E %>% arrange(factor(SampleID_euk, levels = colnames(otu_table(ps_euk_ra_oxycline_pruned))))
sample_names(ps_euk_ra_oxycline_pruned) <- samplekey_E$Type
sample_names(ps_euk_oxycline_pruned) <- samplekey_E$Type

```


Move all pruned otu tables into one table by matching the sample Type- will use this for SparCC
```{r}
alldomains_df_oxycline <- bind_rows(data.frame(otu_table(ps_bac_oxycline_pruned)), data.frame(otu_table(ps_arch_oxycline_pruned)), data.frame(otu_table(ps_euk_oxycline_pruned)))
alldomains_df_oxycline
```

Change row names from "denovoXXX" to meaningful names
```{r}
alldomains_df_oxycline <- cbind(ID = rownames(alldomains_df_oxycline), alldomains_df_oxycline)

# start with only first rows, which are bacteria. make one column of meaningful labels
temp1 <- left_join(alldomains_df_oxycline[1:dim(otu_table(ps_bac_oxycline_pruned))[1],], bac_taxonomy, by = c("ID" = "#OTU ID")) 
temp1$New_ID <- paste(temp1$ID, temp1$"taxonomy-2", temp1$"taxonomy-3", temp1$"taxonomy-4")
temp1 <- select(temp1,-colnames(bac_taxonomy[,2:11]))

# next rows are the archaea 
temp2 <- left_join(alldomains_df_oxycline[sum(dim(otu_table(ps_bac_oxycline_pruned))[1],1):sum(dim(otu_table(ps_bac_oxycline_pruned))[1],dim(otu_table(ps_arch_oxycline_pruned))[1]),], arch_taxonomy, by = c("ID" = "#OTU ID")) 
temp2$New_ID <- paste(temp2$ID, temp2$"taxonomy-2", temp2$"taxonomy-3")
temp2 <- select(temp2,-colnames(arch_taxonomy[,2:9]))


# last rows are eukarya
euk_taxonomy <- cbind("#ASV ID" = rownames(taxonomy), taxonomy)
temp3 <- left_join(alldomains_df_oxycline[sum(dim(otu_table(ps_arch_oxycline_pruned))[1], dim(otu_table(ps_bac_oxycline_pruned))[1],1):sum(dim(otu_table(ps_arch_oxycline_pruned))[1], dim(otu_table(ps_bac_oxycline_pruned))[1],dim(otu_table(ps_euk_oxycline_pruned))[1]),], euk_taxonomy, by = c("ID" = "#ASV ID")) 
temp3$New_ID <- paste(temp3$ID, temp3$"Supergroup", temp3$"Division", temp3$"Class", temp3$"Order")
temp3 <- select(temp3,-colnames(euk_taxonomy[,2:9]))

# combine back all 3 domains, with new names as row names in a dataframe
alldomains_df_oxycline <- rbind(temp1, temp2, temp3)
alldomains_df_oxycline <- data.frame(alldomains_df_oxycline)
rownames(alldomains_df_oxycline) <- alldomains_df_oxycline$New_ID
alldomains_df_oxycline <- select(alldomains_df_oxycline, -c("ID","New_ID"))
alldomains_df_oxycline
```



Remove columns with NAs. These are samples for which the library for at least one domain didn't work (can't do correlations with missing values in columns)
```{r}
alldomains_df_oxycline <- alldomains_df_oxycline %>%
    select_if(~ !any(is.na(.)))
alldomains_df_oxycline
```
21 samples remain for correlation








### Filter low abundance species- anoxic depths only

Pull out samples from shallow anoxic regime
```{r}
# Pull out anoxic layer bacteria sample IDs
anoxictypes_bac <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_bac)) %>%
  filter(OxCond == "ShallowAnoxic") %>% 
  select("Sample Name")
anoxictypes_bac <- unlist(c(unique(anoxictypes_bac)), use.names = FALSE)

# Pull out all bacteria from anoxic layer
ps_bac_anoxic <-  prune_samples(anoxictypes_bac, ps_bac)
ps_bac_ra_anoxic <-  prune_samples(anoxictypes_bac, ps_bac_ra)


# Pull out anoxic layer archaea sample IDs
anoxictypes_arch <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_arch)) %>%
  filter(OxCond == "ShallowAnoxic") %>% 
  select("Sample Name")
anoxictypes_arch <- unlist(c(unique(anoxictypes_arch)), use.names = FALSE)

# Pull out all archaea from anoxic layer
ps_arch_anoxic<-  prune_samples(anoxictypes_arch, ps_arch)
ps_arch_ra_anoxic <-  prune_samples(anoxictypes_arch, ps_arch_ra)


# Pull out anoxic layer eukaryotic sample IDs
anoxictypes_euk <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps)) %>%
  filter(OxCond == "ShallowAnoxic") %>% 
  select("Sample Name")
anoxictypes_euk <- unlist(c(unique(anoxictypes_euk)), use.names = FALSE)

# Pull out all eukaryotes from anoxic layer
ps_euk_anoxic <-  prune_samples(anoxictypes_euk, ps)
ps_euk_ra_anoxic <-  prune_samples(anoxictypes_euk, ps_ra)

```

Filter out low abundance taxa from the oxycline samples. Use 5% as cutoff 
```{r}
# Bacteria
x <- taxa_sums(ps_bac_ra_anoxic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_bac_ra_anoxic_pruned <-  prune_taxa(keepTaxa, ps_bac_ra_anoxic)
ps_bac_anoxic_pruned <-  prune_taxa(keepTaxa, ps_bac_anoxic)
ps_bac_ra_anoxic_pruned
ps_bac_anoxic_pruned

# Archaea
x <- taxa_sums(ps_arch_ra_anoxic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_arch_ra_anoxic_pruned <-  prune_taxa(keepTaxa, ps_arch_ra_anoxic)
ps_arch_anoxic_pruned <-  prune_taxa(keepTaxa, ps_arch_anoxic)
ps_arch_ra_anoxic_pruned
ps_arch_anoxic_pruned

# Eukaryotes
x <- taxa_sums(ps_euk_ra_anoxic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_euk_ra_anoxic_pruned <-  prune_taxa(keepTaxa, ps_euk_ra_anoxic)
ps_euk_anoxic_pruned <-  prune_taxa(keepTaxa, ps_euk_anoxic)
ps_euk_ra_anoxic_pruned
ps_euk_anoxic_pruned

```
32 bacteria, 19 archaea, 37 eukaryota remain


Change the sample names in the otu tables to "Type"
```{r}
# Archaea
# remove missing archaea samples from samplekey_A
samplekey_A <- filter(samplekey, SampleID_arch  %in% colnames(otu_table(ps_arch_ra_anoxic_pruned)))
# sort SampleKey by order of column names from ps_arch_ra_anoxic_pruned
samplekey_A <- samplekey_A %>% arrange(factor(SampleID_arch, levels = colnames(otu_table(ps_arch_ra_anoxic_pruned))))
# replace col names of otu table from ps_arch_ra_anoxic_pruned
sample_names(ps_arch_ra_anoxic_pruned) <- samplekey_A$Type
# and ps_arch_pruned
sample_names(ps_arch_anoxic_pruned) <- samplekey_A$Type


# Bacteria
samplekey_B <- filter(samplekey, SampleID_bac  %in% colnames(otu_table(ps_bac_ra_anoxic_pruned)))
samplekey_B <- samplekey_B %>% arrange(factor(SampleID_bac, levels = colnames(otu_table(ps_bac_ra_anoxic_pruned))))
sample_names(ps_bac_ra_anoxic_pruned) <- samplekey_B$Type
sample_names(ps_bac_anoxic_pruned) <- samplekey_B$Type


# Eukaryotes
samplekey_E <- filter(samplekey, SampleID_euk  %in% colnames(otu_table(ps_euk_ra_anoxic_pruned)))
samplekey_E <- samplekey_E %>% arrange(factor(SampleID_euk, levels = colnames(otu_table(ps_euk_ra_anoxic_pruned))))
sample_names(ps_euk_ra_anoxic_pruned) <- samplekey_E$Type
sample_names(ps_euk_anoxic_pruned) <- samplekey_E$Type

```


Move all pruned otu tables into one table by matching the sample Type- will use this for SparCC
```{r}
alldomains_df_anoxic <- bind_rows(data.frame(otu_table(ps_bac_anoxic_pruned)), data.frame(otu_table(ps_arch_anoxic_pruned)), data.frame(otu_table(ps_euk_anoxic_pruned)))
alldomains_df_anoxic
```

Change row names from "denovoXXX" to meaningful names
```{r}
alldomains_df_anoxic <- cbind(ID = rownames(alldomains_df_anoxic), alldomains_df_anoxic)

# start with only first rows, which are bacteria. make one column of meaningful labels
temp1 <- left_join(alldomains_df_anoxic[1:dim(otu_table(ps_bac_anoxic_pruned))[1],], bac_taxonomy, by = c("ID" = "#OTU ID")) 
temp1$New_ID <- paste(temp1$ID, temp1$"taxonomy-2", temp1$"taxonomy-3", temp1$"taxonomy-4")
temp1 <- select(temp1,-colnames(bac_taxonomy[,2:11]))

# next rows are the archaea 
temp2 <- left_join(alldomains_df_anoxic[sum(dim(otu_table(ps_bac_anoxic_pruned))[1],1):sum(dim(otu_table(ps_bac_anoxic_pruned))[1],dim(otu_table(ps_arch_anoxic_pruned))[1]),], arch_taxonomy, by = c("ID" = "#OTU ID")) 
temp2$New_ID <- paste(temp2$ID, temp2$"taxonomy-2", temp2$"taxonomy-3")
temp2 <- select(temp2,-colnames(arch_taxonomy[,2:9]))


# last rows are eukarya
euk_taxonomy <- cbind("#ASV ID" = rownames(taxonomy), taxonomy)
temp3 <- left_join(alldomains_df_anoxic[sum(dim(otu_table(ps_arch_anoxic_pruned))[1], dim(otu_table(ps_bac_anoxic_pruned))[1],1):sum(dim(otu_table(ps_arch_anoxic_pruned))[1], dim(otu_table(ps_bac_anoxic_pruned))[1],dim(otu_table(ps_euk_anoxic_pruned))[1]),], euk_taxonomy, by = c("ID" = "#ASV ID")) 
temp3$New_ID <- paste(temp3$ID, temp3$"Supergroup", temp3$"Division", temp3$"Class", temp3$"Order")
temp3 <- select(temp3,-colnames(euk_taxonomy[,2:9]))

# combine back all 3 domains, with new names as row names in a dataframe
alldomains_df_anoxic <- rbind(temp1, temp2, temp3)
alldomains_df_anoxic <- data.frame(alldomains_df_anoxic)
rownames(alldomains_df_anoxic) <- alldomains_df_anoxic$New_ID
alldomains_df_anoxic <- select(alldomains_df_anoxic, -c("ID","New_ID"))
alldomains_df_anoxic
```



Remove columns with NAs. These are samples for which the library for at least one domain didn't work (can't do correlations with missing values in columns)
```{r}
alldomains_df_anoxic <- alldomains_df_anoxic %>%
    select_if(~ !any(is.na(.)))
alldomains_df_anoxic
```
11 samples remain for correlation





### Filter low abundance species- euxinic depths only

Pull out samples from shallow anoxic regime
```{r}
# Pull out anoxic layer bacteria sample IDs
euxinictypes_bac <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_bac)) %>%
  filter(OxCond == "Euxinic") %>% 
  select("Sample Name")
euxinictypes_bac <- unlist(c(unique(euxinictypes_bac)), use.names = FALSE)

# Pull out all bacteria from euxinic layer
ps_bac_euxinic <-  prune_samples(euxinictypes_bac, ps_bac)
ps_bac_ra_euxinic <-  prune_samples(euxinictypes_bac, ps_bac_ra)


# Pull out euxinic layer archaea sample IDs
euxinictypes_arch <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps_arch)) %>%
  filter(OxCond == "Euxinic") %>% 
  select("Sample Name")
euxinictypes_arch <- unlist(c(unique(euxinictypes_arch)), use.names = FALSE)

# Pull out all archaea from euxinic layer
ps_arch_euxinic<-  prune_samples(euxinictypes_arch, ps_arch)
ps_arch_ra_euxinic <-  prune_samples(euxinictypes_arch, ps_arch_ra)


# Pull out euxinic layer eukaryotic sample IDs
euxinictypes_euk <- metadata %>% 
  filter(`Sample Name` %in% sample_names(ps)) %>%
  filter(OxCond == "Euxinic") %>% 
  select("Sample Name")
euxinictypes_euk <- unlist(c(unique(euxinictypes_euk)), use.names = FALSE)

# Pull out all eukaryotes from euxinic layer
ps_euk_euxinic <-  prune_samples(euxinictypes_euk, ps)
ps_euk_ra_euxinic <-  prune_samples(euxinictypes_euk, ps_ra)

```

Filter out low abundance taxa from the oxycline samples. Use 5% as cutoff 
```{r}
# Bacteria
x <- taxa_sums(ps_bac_ra_euxinic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_bac_ra_euxinic_pruned <-  prune_taxa(keepTaxa, ps_bac_ra_euxinic)
ps_bac_euxinic_pruned <-  prune_taxa(keepTaxa, ps_bac_euxinic)
ps_bac_ra_euxinic_pruned
ps_bac_euxinic_pruned

# Archaea
x <- taxa_sums(ps_arch_ra_euxinic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_arch_ra_euxinic_pruned <-  prune_taxa(keepTaxa, ps_arch_ra_euxinic)
ps_arch_euxinic_pruned <-  prune_taxa(keepTaxa, ps_arch_euxinic)
ps_arch_ra_euxinic_pruned
ps_arch_euxinic_pruned

# Eukaryotes
x <- taxa_sums(ps_euk_ra_euxinic)
keepTaxa <-  x>.05 # prune_taxa require a logical not a list of IDs. compare to keepTaxa above to check
ps_euk_ra_euxinic_pruned <-  prune_taxa(keepTaxa, ps_euk_ra_euxinic)
ps_euk_euxinic_pruned <-  prune_taxa(keepTaxa, ps_euk_euxinic)
ps_euk_ra_euxinic_pruned
ps_euk_euxinic_pruned

```
16 bacteria, 16 archaea, 20 eukaryota remain


Change the sample names in the otu tables to "Type"
```{r}
# Archaea
# remove missing archaea samples from samplekey_A
samplekey_A <- filter(samplekey, SampleID_arch  %in% colnames(otu_table(ps_arch_ra_euxinic_pruned)))
# sort SampleKey by order of column names from ps_arch_ra_euxinic_pruned
samplekey_A <- samplekey_A %>% arrange(factor(SampleID_arch, levels = colnames(otu_table(ps_arch_ra_euxinic_pruned))))
# replace col names of otu table from ps_arch_ra_euxinic_pruned
sample_names(ps_arch_ra_euxinic_pruned) <- samplekey_A$Type
# and ps_arch_pruned
sample_names(ps_arch_euxinic_pruned) <- samplekey_A$Type


# Bacteria
samplekey_B <- filter(samplekey, SampleID_bac  %in% colnames(otu_table(ps_bac_ra_euxinic_pruned)))
samplekey_B <- samplekey_B %>% arrange(factor(SampleID_bac, levels = colnames(otu_table(ps_bac_ra_euxinic_pruned))))
sample_names(ps_bac_ra_euxinic_pruned) <- samplekey_B$Type
sample_names(ps_bac_euxinic_pruned) <- samplekey_B$Type


# Eukaryotes
samplekey_E <- filter(samplekey, SampleID_euk  %in% colnames(otu_table(ps_euk_ra_euxinic_pruned)))
samplekey_E <- samplekey_E %>% arrange(factor(SampleID_euk, levels = colnames(otu_table(ps_euk_ra_euxinic_pruned))))
sample_names(ps_euk_ra_euxinic_pruned) <- samplekey_E$Type
sample_names(ps_euk_euxinic_pruned) <- samplekey_E$Type

```


Move all pruned otu tables into one table by matching the sample Type- will use this for SparCC
```{r}
alldomains_df_euxinic <- bind_rows(data.frame(otu_table(ps_bac_euxinic_pruned)), data.frame(otu_table(ps_arch_euxinic_pruned)), data.frame(otu_table(ps_euk_euxinic_pruned)))
alldomains_df_euxinic
```

Change row names from "denovoXXX" to meaningful names
```{r}
alldomains_df_euxinic <- cbind(ID = rownames(alldomains_df_euxinic), alldomains_df_euxinic)

# start with only first rows, which are bacteria. make one column of meaningful labels
temp1 <- left_join(alldomains_df_euxinic[1:dim(otu_table(ps_bac_euxinic_pruned))[1],], bac_taxonomy, by = c("ID" = "#OTU ID")) 
temp1$New_ID <- paste(temp1$ID, temp1$"taxonomy-2", temp1$"taxonomy-3", temp1$"taxonomy-4")
temp1 <- select(temp1,-colnames(bac_taxonomy[,2:11]))

# next rows are the archaea 
temp2 <- left_join(alldomains_df_euxinic[sum(dim(otu_table(ps_bac_euxinic_pruned))[1],1):sum(dim(otu_table(ps_bac_euxinic_pruned))[1],dim(otu_table(ps_arch_euxinic_pruned))[1]),], arch_taxonomy, by = c("ID" = "#OTU ID")) 
temp2$New_ID <- paste(temp2$ID, temp2$"taxonomy-2", temp2$"taxonomy-3")
temp2 <- select(temp2,-colnames(arch_taxonomy[,2:9]))


# last rows are eukarya
euk_taxonomy <- cbind("#ASV ID" = rownames(taxonomy), taxonomy)
temp3 <- left_join(alldomains_df_euxinic[sum(dim(otu_table(ps_arch_euxinic_pruned))[1], dim(otu_table(ps_bac_euxinic_pruned))[1],1):sum(dim(otu_table(ps_arch_euxinic_pruned))[1], dim(otu_table(ps_bac_euxinic_pruned))[1],dim(otu_table(ps_euk_euxinic_pruned))[1]),], euk_taxonomy, by = c("ID" = "#ASV ID")) 
temp3$New_ID <- paste(temp3$ID, temp3$"Supergroup", temp3$"Division", temp3$"Class", temp3$"Order")
temp3 <- select(temp3,-colnames(euk_taxonomy[,2:9]))

# combine back all 3 domains, with new names as row names in a dataframe
alldomains_df_euxinic <- rbind(temp1, temp2, temp3)
alldomains_df_euxinic <- data.frame(alldomains_df_euxinic)
rownames(alldomains_df_euxinic) <- alldomains_df_euxinic$New_ID
alldomains_df_euxinic <- select(alldomains_df_euxinic, -c("ID","New_ID"))
alldomains_df_euxinic
```



Remove columns with NAs. These are samples for which the library for at least one domain didn't work (can't do correlations with missing values in columns)
```{r}
alldomains_df_euxinic <- alldomains_df_euxinic %>%
    select_if(~ !any(is.na(.)))
alldomains_df_euxinic
```
4 samples remain for correlation






## SparCC 
### SparCC on full dataset
This is largely based on [BVCN tutorials](https://github.com/biovcnet/biovcnet.github.io/wiki/TOPIC%3A-Networks)
NOTE- input for SparCC should be raw count data (after filtering out low-abundance ASVs). The function does a log-ratio transformation to account for compositionality

```{r}
sparcctable_alldomains <- sparcc(t(alldomains_df))
```

Put sample names back into result tables
```{r}
rownames(sparcctable_alldomains$Cor) <- rownames(alldomains_df_full)
colnames(sparcctable_alldomains$Cor) <- rownames(alldomains_df_full)
rownames(sparcctable_alldomains$Cov) <- rownames(alldomains_df_full)
colnames(sparcctable_alldomains$Cov) <- rownames(alldomains_df_full)

sparcctable_alldomains$Cor[1:2,1:2]

```



Plot correlation
```{r}
plotableSparcc <- sparcctable_alldomains$Cor %>% reorder_cormat %>% get_upper_tri() %>% reshape2::melt() %>% na.omit()

Sparcc_plot <- plotableSparcc %>% ggplot(aes(x = Var2, y = Var1, fill = value)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))

Sparcc_plot

# ggsave("figures/sparcc_corr_alldomains.eps",Sparcc_plot, width = 35, height = 35, units = c("in"))
```



Calculate Sparcc p-values by bootstrapping- TAKES A LONG TIME
```{r}
# tp0 <- proc.time()
# out2 <- sparccboot(t(alldomains_df), R = 1000, ncpus = 2)
# tp1 <- proc.time()
# tp1 - tp0
```
The above took ~14 hours to run 1000 iterations


Extract p-values 
```{r}
outP <- pval.sparccboot(out2)
data.frame(outP$cors, outP$pvals) %>% head
cors <- outP$cors
pvals <- outP$pvals
sparCCpcors <- diag(0.5, nrow = dim(sparcctable_alldomains$Cor)[1], ncol = dim(sparcctable_alldomains$Cor)[1])
sparCCpcors[upper.tri(sparCCpcors, diag=FALSE)] <- cors
sparCCpcors <- sparCCpcors + t(sparCCpcors)

sparCCpval <- diag(0.5, nrow = dim(sparcctable_alldomains$Cor)[1], ncol = dim(sparcctable_alldomains$Cor)[1])
sparCCpval[upper.tri(sparCCpval, diag=FALSE)] <- pvals
sparCCpval <- sparCCpval + t(sparCCpval)

rownames(sparCCpcors) <- rownames(alldomains_df_full)
colnames(sparCCpcors) <- rownames(alldomains_df_full)
rownames(sparCCpval) <- rownames(alldomains_df_full)
colnames(sparCCpval) <- rownames(alldomains_df_full)

sparCCpcors[1:2, 1:2]
sparCCpval[1:2, 1:2]
```

Reorder for plotting
```{r}
reordered_all_sparcc <- reorder_cor_and_p(sparCCpcors, sparCCpval)
reordered_sparccCor <- reordered_all_sparcc$r
reordered_sparccP<- reordered_all_sparcc$p


sparccCor_processed <- reordered_sparccCor  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(cor = value)
sparccP_processed <- reordered_sparccP  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(p = value)

# join the two data frames

SparccP <- left_join(sparccCor_processed, sparccP_processed, by = c("Var1", "Var2")) %>%
  # # remove self correlations
  # filter(Var1 != Var2) %>% 
  # calculate the false discovery rate to adjust for multiple p values
  mutate(fdr = p.adjust(p, method = "BH"))
```


And plot correlation with p-values. Circles mean that the relationship is sig. at p = 0.05 level, based on bootstrapping
```{r}
fdrThresh <- 0.01 # fdr threshold
sparccOkP <- SparccP%>% filter(fdr < fdrThresh) 

SparccP_plot <- SparccP %>% ggplot(aes(x = Var2, y = Var1, fill = cor)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + geom_point(data = sparccOkP, shape = 1)

SparccP_plot

ggsave("figures/sparcc_corr_alldomains_w_pvals.eps",SparccP_plot, width = 35, height = 35, units = c("in"))

```



Save environment again
```{r}
# save.image("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_sparcc_bootstrap.RData")
```

Or load if coming back
```{r}
load("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_sparcc_bootstrap.RData")
```





## SpiecEasi

Try the SpiecEasi method, which accounts for sparse data, as described in the [SpiecEasi publication](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004226), [spieceasi github](https://github.com/zdk123/SpiecEasi), and [BVCN lessons 1.2](https://biovcnet.github.io/_pages/NetworkScience_glasso). This reduces the clumps (eg. sparse relationships that are secondary or teriary, not direct relationships).

Make functions from tutorial
```{r}
convertSEToTable <- function(se_out,sp.names){
  #This is just a fancy helper function to get the data in a comparable format to the output of lesson 1 so we can make a similar plot. We will cover other methods for visualizing this type of output in future lessons.
  secor <- cov2cor(as.matrix(getOptCov(se_out))) # See spieceasi documentation for how to pull out weights for comparison
  elist     <- summary(triu(secor*getRefit(se_out), k=1))
  elist[,1] <- sp.names[elist[,1]]
  elist[,2] <- sp.names[elist[,2]]
  elist[,4] <- paste(elist[,1],elist[,2])
  full_e <- expand.grid(sp.names,sp.names)
  rownames(full_e) <- paste(full_e[,1],full_e[,2])
  full_e[,"Weight"] <- 0
  full_e[elist[,4],"Weight"] <- elist[,3]
  x <- expand.grid(1:length(sp.names),1:length(sp.names))
  full_e[x[,"Var1"]>x[,"Var2"],"Weight"] <- NA
  return(as.data.frame(full_e,stringsAsFactors=F))
}
```

### SpiecEasi on full dataset
Follow the spieceasi [documentation](https://github.com/zdk123/SpiecEasi) to find optimal parameters

Remove samples from the phyloseq objects that are not in all 3 domains and reorder samples so they are in same order in all 3 objects
```{r}
bac_arch_common <- intersect(sample_names(ps_bac_ra_pruned), sample_names(ps_arch_ra_pruned))
all_common <- intersect(bac_arch_common, sample_names(ps_euk_ra_pruned))

ps_bac_pruned <- prune_samples(all_common, ps_bac_pruned)
ps_arch_pruned <- prune_samples(all_common, ps_arch_pruned)
ps_euk_pruned <- prune_samples(all_common, ps_euk_pruned)

ps_bac_ra_pruned <- prune_samples(all_common, ps_bac_ra_pruned)
ps_arch_ra_pruned <- prune_samples(all_common, ps_arch_ra_pruned)
ps_euk_ra_pruned <- prune_samples(all_common, ps_euk_ra_pruned)


otu_table(ps_arch_pruned) <- otu_table(ps_arch_pruned)[,sample_names(ps_bac_ra_pruned)]
otu_table(ps_euk_pruned) <- otu_table(ps_euk_pruned)[,sample_names(ps_bac_ra_pruned)]

sample_data(ps_bac_pruned)
sample_data(ps_arch_pruned)
sample_data(ps_euk_pruned)
```



```{r}
#Run Spieceasi
pargs <- list(seed=10010)
se <- spiec.easi(list(ps_bac_pruned, ps_arch_pruned, ps_euk_pruned), method='glasso', lambda.min.ratio=5e-1,nlambda=100, pulsar.params=list(rep.num=50))
getStability(se)
```

the above takes a couple of minutes to run

```{r}
#This is just a fancy helper function to get the data in a comparable format to the output of above
tab.se <- convertSEToTable(se,sp.names=colnames(t(alldomains_df_full))) 

#Plot 
plot.se <- ggplot(tab.se,aes(x = Var1, y = Var2, fill = Weight)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
plot(plot.se)

ggsave("figures/spieceasi_alldomains.eps",plot.se, width = 35, height = 35, units = c("in"))

```
Note- only the significant values above show up in the heatmap above (ie. there is no "p-value")

### SpiecEasi on oxycline depths

```{r}
bac_arch_common <- intersect(sample_names(ps_bac_oxycline_pruned), sample_names(ps_arch_oxycline_pruned))
all_common <- intersect(bac_arch_common, sample_names(ps_euk_oxycline_pruned))

ps_bac_oxycline_pruned <- prune_samples(all_common, ps_bac_oxycline_pruned)
ps_arch_oxycline_pruned <- prune_samples(all_common, ps_arch_oxycline_pruned)
ps_euk_oxycline_pruned <- prune_samples(all_common, ps_euk_oxycline_pruned)


otu_table(ps_arch_oxycline_pruned) <- otu_table(ps_arch_oxycline_pruned)[,sample_names(ps_bac_oxycline_pruned)]
otu_table(ps_euk_oxycline_pruned) <- otu_table(ps_euk_oxycline_pruned)[,sample_names(ps_bac_oxycline_pruned)]

sample_data(ps_bac_oxycline_pruned)
sample_data(ps_arch_oxycline_pruned)
sample_data(ps_euk_oxycline_pruned)
```



```{r}
#Run Spieceasi
pargs <- list(seed=10010)
se.oxycline <- spiec.easi(list(ps_bac_oxycline_pruned, ps_arch_oxycline_pruned, ps_euk_oxycline_pruned), method='glasso', lambda.min.ratio=5e-1,nlambda=100, pulsar.params=list(rep.num=50))
getStability(se.oxycline)
```

the above takes a couple of minutes to run

```{r}
# Pull out spp names from oxcyline phyloseq objects and concatenate


#This is just a fancy helper function to get the data in a comparable format to the output of above
tab.se.oxycline <- convertSEToTable(se.oxycline, sp.names=colnames(t(alldomains_df_oxycline))) 

#Plot 
plot.se.oxycline <- ggplot(tab.se.oxycline,aes(x = Var1, y = Var2, fill = Weight)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
plot(plot.se.oxycline)

ggsave("figures/spieceasi_alldomains_oxycline.eps",plot.se.oxycline, width = 35, height = 35, units = c("in"))

```



### SpiecEasi on anoxic depths

```{r}
bac_arch_common <- intersect(sample_names(ps_bac_anoxic_pruned), sample_names(ps_arch_anoxic_pruned))
all_common <- intersect(bac_arch_common, sample_names(ps_euk_anoxic_pruned))

ps_bac_anoxic_pruned <- prune_samples(all_common, ps_bac_anoxic_pruned)
ps_arch_anoxic_pruned <- prune_samples(all_common, ps_arch_anoxic_pruned)
ps_euk_anoxic_pruned <- prune_samples(all_common, ps_euk_anoxic_pruned)


otu_table(ps_arch_anoxic_pruned) <- otu_table(ps_arch_anoxic_pruned)[,sample_names(ps_bac_anoxic_pruned)]
otu_table(ps_euk_anoxic_pruned) <- otu_table(ps_euk_anoxic_pruned)[,sample_names(ps_bac_anoxic_pruned)]

sample_data(ps_bac_anoxic_pruned)
sample_data(ps_arch_anoxic_pruned)
sample_data(ps_euk_anoxic_pruned)
```



```{r}
#Run Spieceasi
pargs <- list(seed=10010)
se.anoxic <- spiec.easi(list(ps_bac_anoxic_pruned, ps_arch_anoxic_pruned, ps_euk_anoxic_pruned), method='glasso', lambda.min.ratio=5e-1,nlambda=100, pulsar.params=list(rep.num=50))
getStability(se.anoxic)
```

the above takes a couple of minutes to run

```{r}
# Pull out spp names from oxcyline phyloseq objects and concatenate


#This is just a fancy helper function to get the data in a comparable format to the output of above
tab.se.anoxic <- convertSEToTable(se.anoxic, sp.names=colnames(t(alldomains_df_anoxic))) 

#Plot 
plot.se.anoxic <- ggplot(tab.se.anoxic,aes(x = Var1, y = Var2, fill = Weight)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
plot(plot.se.anoxic)

ggsave("figures/spieceasi_alldomains_anoxic.eps",plot.se.anoxic, width = 35, height = 35, units = c("in"))

```



### SpiecEasi on euxinic depths

```{r}
bac_arch_common <- intersect(sample_names(ps_bac_euxinic_pruned), sample_names(ps_arch_euxinic_pruned))
all_common <- intersect(bac_arch_common, sample_names(ps_euk_euxinic_pruned))

ps_bac_euxinic_pruned <- prune_samples(all_common, ps_bac_euxinic_pruned)
ps_arch_euxinic_pruned <- prune_samples(all_common, ps_arch_euxinic_pruned)
ps_euk_euxinic_pruned <- prune_samples(all_common, ps_euk_euxinic_pruned)


otu_table(ps_arch_euxinic_pruned) <- otu_table(ps_arch_euxinic_pruned)[,sample_names(ps_bac_euxinic_pruned)]
otu_table(ps_euk_euxinic_pruned) <- otu_table(ps_euk_euxinic_pruned)[,sample_names(ps_bac_euxinic_pruned)]

sample_data(ps_bac_euxinic_pruned)
sample_data(ps_arch_euxinic_pruned)
sample_data(ps_euk_euxinic_pruned)
```



```{r}
#Run Spieceasi
pargs <- list(seed=10010)
se.euxinic <- spiec.easi(list(ps_bac_euxinic_pruned, ps_arch_euxinic_pruned, ps_euk_euxinic_pruned), method='glasso', lambda.min.ratio=5e-2,nlambda=1000, pulsar.params=list(rep.num=50))
getStability(se.euxinic)
```

I tried many parameters on the above but cannot get a satisfactory solution. There are just too few samples (4 after quality filtering) to do SpiecEasi on the euxinic depths only.



### Save and re-load environment
```{r}
# save.image("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_spieceasi.RData")
```

Or load if coming back
```{r}
load("EnvironmentBackups/CariacoEuks_postanalysis_vars_upto_spieceasi.RData")
```


## Network Analysis
Build using igraph

### 3 Domain Network- All depths
```{r}
#Extract adjacency matrix from spiecEasi output
adj.mat <- getRefit(se)
table(as.numeric(adj.mat))

# Extract weighted adjacency
se.cor  <- cov2cor(as.matrix(getOptCov(se)))
weighted.adj.mat <- se.cor*getRefit(se)

#Convert to graph objects
grph.unweighted <- adj2igraph(adj.mat)
grph <- adj2igraph(weighted.adj.mat)


# Put back in species names
V(grph)$name <- rownames(alldomains_df)
# V(grph)

# Make size of nodes proportional to degree (number of connections)
V(grph)$size <- (degree(grph) + 1) # the +1 avoids size zero vertices

# Color edges by connection (positive or negative) 
# E(grph)$color <- custombluegreen
# E(grph)$color[E(grph)$weight<0] <- customreddishpurple

# Change width of edges to be proportional to their weights
E(grph)$width <- abs(E(grph)$weight)*10

# Scale node sizes to be smaller
V(grph)$size <- V(grph)$size/2

# Remove low-weight edges (you decide what threshold is right for your network):
# weight_threshold <- 0.07
# grph <- delete.edges(grph,which(abs(E(grph)$weight)<weight_threshold))

# Color nodes by domain
dtype <- c(rep("red",ntaxa(ps_bac_pruned)), rep("green",ntaxa(ps_arch_pruned)), rep("blue",ntaxa(ps_euk_pruned)))

# Plot
plot(grph,
     vertex.label=NA,
     layout=layout_with_graphopt(grph),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Whole Water Column")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)

# Save plot
setEPS()
postscript(file = "Figures/3domains_alldepths_spieceasi_network.eps", width = 5.5, height = 5)
plot(grph,
     vertex.label=NA,
     layout=layout_with_graphopt(grph),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Whole Water Column")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)
dev.off()
```


### 3 Domain Network- Oxycline
```{r}
#Extract adjacency matrix from spiecEasi output
adj.mat <- getRefit(se.oxycline)
table(as.numeric(adj.mat))

# Extract weighted adjacency
se.cor  <- cov2cor(as.matrix(getOptCov(se.oxycline)))
weighted.adj.mat <- se.cor*getRefit(se.oxycline)

#Convert to graph objects
grph.unweighted.oxycline <- adj2igraph(adj.mat)
grph.oxycline <- adj2igraph(weighted.adj.mat)


# Put back in species names
V(grph.oxycline)$name <- rownames(alldomains_df_oxycline)
# V(grph.oxycline)

# Make size of nodes proportional to degree (number of connections)
V(grph.oxycline)$size <- (degree(grph.oxycline) + 1) # the +1 avoids size zero vertices

# Color edges by connection (positive or negative) 
# E(grph.oxycline)$color <- custombluegreen
# E(grph.oxycline)$color[E(grph.oxycline)$weight<0] <- customreddishpurple

# Change width of edges to be proportional to their weights
E(grph.oxycline)$width <- abs(E(grph.oxycline)$weight)*10

# Scale node sizes to be smaller
V(grph.oxycline)$size <- V(grph.oxycline)$size/2

# Remove low-weight edges (you decide what threshold is right for your network):
# weight_threshold <- 0.07
# grph.oxycline <- delete.edges(grph.oxycline,which(abs(E(grph.oxycline)$weight)<weight_threshold))

# Color nodes by domain
dtype <- c(rep("red",ntaxa(ps_bac_oxycline_pruned)), rep("green",ntaxa(ps_arch_oxycline_pruned)), rep("blue",ntaxa(ps_euk_oxycline_pruned)))

# Plot
plot(grph.oxycline,
     vertex.label=NA,
     layout=layout_with_graphopt(grph.oxycline),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Oxycline")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)

# Save plot
setEPS()
postscript(file = "Figures/3domains_oxycline_spieceasi_network.eps", width = 5.5, height = 5)
plot(grph.oxycline,
     vertex.label=NA,
     layout=layout_with_graphopt(grph.oxycline),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Oxycline")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)
dev.off()
```

### 3 Domain Network- Anoxic
```{r}
#Extract adjacency matrix from spiecEasi output
adj.mat <- getRefit(se.anoxic)
table(as.numeric(adj.mat))

# Extract weighted adjacency
se.cor  <- cov2cor(as.matrix(getOptCov(se.anoxic)))
weighted.adj.mat <- se.cor*getRefit(se.anoxic)

#Convert to graph objects
grph.unweighted.anoxic <- adj2igraph(adj.mat)
grph.anoxic <- adj2igraph(weighted.adj.mat)


# Put back in species names
V(grph.anoxic)$name <- rownames(alldomains_df_oxycline)
# V(grph.anoxic)

# Make size of nodes proportional to degree (number of connections)
V(grph.anoxic)$size <- (degree(grph.anoxic) + 1) # the +1 avoids size zero vertices

# Color edges by connection (positive or negative) 
# E(grph.anoxic)$color <- custombluegreen
# E(grph.anoxic)$color[E(grph.anoxic)$weight<0] <- customreddishpurple

# Change width of edges to be proportional to their weights
E(grph.anoxic)$width <- abs(E(grph.anoxic)$weight)*10

# Scale node sizes to be smaller
V(grph.anoxic)$size <- V(grph.anoxic)$size/2

# Remove low-weight edges (you decide what threshold is right for your network):
# weight_threshold <- 0.07
# grph.anoxic <- delete.edges(grph.anoxic,which(abs(E(grph.anoxic)$weight)<weight_threshold))

# Color nodes by domain
dtype <- c(rep("red",ntaxa(ps_bac_anoxic_pruned)), rep("green",ntaxa(ps_arch_anoxic_pruned)), rep("blue",ntaxa(ps_euk_anoxic_pruned)))

# Plot
plot(grph.anoxic,
     vertex.label=NA,
     layout=layout_with_graphopt(grph.anoxic),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Anoxic Layer")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)

# Save plot
setEPS()
postscript(file = "Figures/3domains_anoxic_spieceasi_network.eps", width = 5.5, height = 5)
plot(grph.anoxic,
     vertex.label=NA,
     layout=layout_with_graphopt(grph.anoxic),
     vertex.color=dtype)
title("SpiecEasi Network: All domains, Anoxic")
legend("topright",bty = "n",
       legend=c("Bacteria","Archaea", "Eukarya"),
       fill=c("red","green","blue"), border=NA)
dev.off()
```




### Assemble a dataset of node-level measures from each network

All depths
```{r}
# First change the weights of the edges (the strength of association) to absolute value. This won't work if negative associations are left with negative signs
E(grph)$weight <- abs(E(grph)$weight)

names=V(grph)$name
de=degree(grph)
st=graph.strength(grph)
be=betweenness(grph, normalized=T)


# assemble dataset and match full taxonomy
fulldateset_node_measures <- data.frame(ID=names, degree=de, strength=st, betweenness=be) 

# Put back bac taxaonomy
temp1 <- left_join(fulldateset_node_measures[1:dim(otu_table(ps_bac_pruned))[1],], bac_taxonomy, by = c("ID" = "#OTU ID")) 
# delete "Taxonomy-9" and "refined Taxonomy" columns 
temp1 <- select(temp1, -"taxonomy-9", -"Refined taxonomy")


temp2 <- left_join(fulldateset_node_measures[sum(dim(otu_table(ps_bac_pruned))[1],1):sum(dim(otu_table(ps_bac_pruned))[1],dim(otu_table(ps_arch_pruned))[1]),], arch_taxonomy, by = c("ID" = "#OTU ID")) 


temp3 <- left_join(fulldateset_node_measures[sum(dim(otu_table(ps_arch_pruned))[1], dim(otu_table(ps_bac_pruned))[1],1):sum(dim(otu_table(ps_arch_pruned))[1], dim(otu_table(ps_bac_pruned))[1],dim(otu_table(ps_euk_pruned))[1]),], euk_taxonomy, by = c("ID" = "#ASV ID")) 
# Rename col names to match those from Bac and Arch
temp3 <- temp3 %>%
  rename("taxonomy-1" = Kingdom, "taxonomy-2" = Supergroup, "taxonomy-3" = Division, "taxonomy-4" = Class, "taxonomy-5" = Order, "taxonomy-6" = Family, "taxonomy-7" = Genus, "taxonomy-8" = Species)

# combine back all 3 domains, with new names as row names in a dataframe
fulldateset_node_measures <- rbind(temp1, temp2, temp3)
fulldateset_node_measures
```

Plot betweeness vs centrality (keystone species analysis)
```{r}
ggplot(fulldateset_node_measures, aes(x = degree, y = betweenness, color = fulldateset_node_measures$"taxonomy-2")) +
  geom_point()
```


## STOPPED HERE. CONTINUE PLAYING WITH PLOT ABOVE. DO SAME FOR OXYCLINE AND ANOXIC ONLY (WILL NEED TO MAKE EDITS IN FILTERING ABOVE FOR CLEAR NAMES). THEN COLLECT OVERALL NETWORK PARAMETERS FOLLOWING: https://dshizuka.github.io/networkanalysis/04_measuring.html#betweenness

### Collect network parameters





